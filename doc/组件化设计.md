# 组件化设计

本文阐述在lan-app中，对于一个确定的节点，在它之上的组件化如何设计

## 组件包含的内容

一个组件至少包含以下几个要素：

+ 数据
+ 函数
+ 定时:解决定时问题
+ 事件
+ 依赖
+ 生命周期

## 组件数据

数据的初始化接口，应该符合基本原则：私有。
在这里，我们可以参考Vue的实现，提供一个data的函数，通过这个函数来完成数据的初始化。

## 组件函数

函数组件需要解决两个问题

+ this：在这里，我们简单的定义为组件自身实例。
+ 分组：参考常见语言的可见域，我们可以知道，一个函数可能存在于实例自身，或者存在于全局。那么我们可以简单地定义两个分组用于区分可见域：

  + global:全局，即是节点级别可见的函数
  + local：实例自身可见。

## 组件定时

计划任务而言，可以划分两类：

+ 长期任务：参考linux中的计划任务设计
+ 短期任务：例如几秒后执行

## 组件事件

事件需要解决两方面的问题：触发和响应。但在此之前，我们应该先分析一下事件的来源。

### 事件的来源

+ 自身发出：是指那些由自身发出，其他组件需要响应的事件。
+ 全局发出:是指那些由节点发出，所有组件都可以响应的时间。

以上两点的解决，可以通过一个简单的命名规则去解决，那么下面我们结合触发和响应看看如何解决。

### 事件的触发

默认情况下，事件只能触发自身可见区域的事件，其他事件需要增加对应的命名空间,例子如下：

+ 私有事件：this.emit("event_name")
+ 全局事件：this.emit("global.event_name")
+ 其他组件：this.emit("xxx.event_name")

### 事件的响应

事件的响应最重要的是如何注册，为了简化问题，不考虑事件的动态注册，事件的注册仅在组件实例化的时候。同样的，事件默认只能响应自身事件，如果需要响应其他组件/全局的事件，那么增加对应组件的命名空间/global即可，这里就不举例子了。

## 组件依赖

组件之所以是组件，是因为他们既独立又需要协作，而依赖就是这种关系的体系。为了简化问题，我们增加一个设定：不允许出现循环依赖。思考依赖，我们会得到以下基本原则：

+ 被依赖的必然首先启动
+ 被依赖的必然最后结束

## 生命周期

生命周期可以划分以下：

+ init：初始化，接受外界的数据，进行初始化，
+ start：启动，受到依赖的影响
+ stop：结束，受到依赖影响
+ uninit：反初始化
